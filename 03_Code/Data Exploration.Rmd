---
title: "Data Exploration"
output: html_document
---

```{r}
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(leaflet)
library(sf)
library(recipes)  
library(stringr)
library(slider) 
```

```{r}
charging_points_raw<- read_csv("../01_Raw_Data/Electric_Vehicle_Charging_Points_2765336306591006216.csv")
charging_session_raw <- read_csv("../01_Raw_Data/EVChargeStationUseSept2018toAug2019.csv")

```

```{r}
cat("Charging Points Summary:\n")
glimpse(charging_points_raw)
cat("\nCharging Sessions Summary:\n")
glimpse(charging_session_raw)
```

```{r}
cat("\nMissing values in Charging Points:\n")
colSums(is.na(charging_points_raw))
cat("\nMissing values in Charging Sessions:\n")
colSums(is.na(charging_session_raw))
charging_session_raw <- charging_session_raw %>%
  rename(Id = `CP ID`)
```

```{r}
charging_points_sf <- st_as_sf(charging_points_raw, coords = c("x", "y"), crs = 27700)

charging_points_latlon <- st_transform(charging_points_sf, 4326)

coords <- st_coordinates(charging_points_latlon)
charging_points_latlon$lon <- coords[, 1]
charging_points_latlon$lat <- coords[, 2]
leaflet(data = charging_points_latlon) %>%
  addProviderTiles(providers$OpenStreetMap) %>%
  addCircleMarkers(
    lng = ~lon, lat = ~lat,
    radius = 5,
    color = "blue",
    fillOpacity = 0.7,
    label = ~as.character(Id)
  ) %>%
  addLegend("bottomright", colors = "blue", labels = "Charging Points") %>%
  setView(lng = mean(charging_points_latlon$lon), lat = mean(charging_points_latlon$lat), zoom = 12)
```

Most Used Stations, not needed!

```{r}
library(lubridate)
charging_session_raw <- charging_session_raw %>%
  mutate(StartMonth = month(`Start Date`, label = TRUE))

charging_session_raw %>%
  count(StartMonth) %>%
  ggplot(aes(x = StartMonth, y = n)) +
    geom_col(fill = "steelblue") +
    labs(title = "Sessions by Month", y = "Number of Sessions")
```

Session distribution over the day\
-\> charging happens during the day

```{r}
charging_session_raw <- charging_session_raw %>%
  mutate(
    StartDateTime = ymd_hms(paste(`Start Date`, `Start Time`))
  )

charging_session_raw %>%
  mutate(hour = hour(StartDateTime)) %>%
  count(hour) %>%
  ggplot(aes(x = hour, y = n)) +
    geom_col(fill = "coral") +
    labs(title = "Charging Sessions by Hour of Day", x = "Hour", y = "Sessions")
```

-   charging session duration distribution

```{r}
charging_session_raw <- charging_session_raw %>%
  mutate(
    StartDateTime = ymd_hms(paste(`Start Date`, `Start Time`)),
    EndDateTime = ymd_hms(paste(`End Date`, `End Time`)),
    duration_minutes = as.numeric(difftime(EndDateTime, StartDateTime, units = "mins")),
    duration_hours = as.numeric(difftime(EndDateTime, StartDateTime, units = "hours"))
  )
charging_session_raw %>%
 # filter(duration_minutes > 0) %>%
  ggplot(aes(x = duration_minutes)) +
    geom_histogram(binwidth = 0.1, fill = "skyblue", color = "white") +
    scale_x_log10(
      breaks = c(1, 2, 5, 10, 20, 30, 60, 120, 240, 480, 1000),
      labels = c("1", "2", "5", "10", "20", "30", "60", "120", "240", "480", "1000")
  )+
    labs(
      title = "Distribution of Charging Session Durations (Log Scale)",
      x = "Duration (minutes, log10 scale)",
      y = "Number of Sessions"
    ) +
    theme_minimal()
```

Graph unfiltered.

```{r}
charging_session_raw %>%
 # filter(duration_minutes > 0, `Total kWh` > 0, `Total kWh`< 100) %>%
  ggplot(aes(x = `Total kWh`)) +
    geom_histogram(binwidth = 5, fill = "skyblue", color = "white")  + scale_x_continuous(
      breaks = seq(0, 300, 5)
    ) +
    labs(
      title = "Distribution of Delivered Charging Energy",
      x = "Energy delivered (kWh)",
      y = "Number of Sessions"
    ) + theme_minimal()
```

-\> I need to filter the sessions with \<0min; \> 1440 min (1 Day); kwh \< 0kWh; These sessions are most probably faulty.

-\> I need to filter the sessions with \<0min; \> 1440 min (1 Day); kwh \< 0kWh; These sessions are most probably faulty.

```{r}
charging_sessions_filtered <- charging_session_raw %>%
  mutate(
    StartDateTime = ymd_hms(paste(`Start Date`, `Start Time`)),
    EndDateTime   = ymd_hms(paste(`End Date`, `End Time`)),
    duration_minutes = as.numeric(difftime(EndDateTime, StartDateTime, units = "mins"))
  ) %>%
  filter(
    duration_minutes >= 0,       # remove negative durations
    duration_minutes <= 1440,    # remove sessions longer than 1 day
    `Total kWh` > 0 ,
    `Total kWh` < 150
    # remove sessions with negative or zero kWh
  )

# Save to Processed folder
write_csv(charging_sessions_filtered, "../02_Processed_Data/charging_sessions_filtered.csv")
```

Graph with the filtered Data for comparison

```{r}

charging_sessions_filtered %>%
  ggplot(aes(x = `Total kWh`)) +
    geom_histogram(binwidth = 5, fill = "skyblue", color = "white")  + scale_x_continuous(
      breaks = seq(0,300, 5)
    ) +
    labs(
      title = "Distribution of Delivered Charging Energy",
      x = "Energy delivered (kWh)",
      y = "Number of Sessions"
    ) + theme_minimal()

charging_sessions_filtered %>%
  ggplot(aes(x = duration_minutes)) +
    geom_histogram(binwidth = 0.1, fill = "skyblue", color = "white") +
    scale_x_log10(
      breaks = c(1, 2, 5, 10, 20, 30, 60, 120, 240, 480, 1000),
      labels = c("1", "2", "5", "10", "20", "30", "60", "120", "240", "480", "1000")
  )+
    labs(
      title = "Distribution of Charging Session Durations (Log Scale)",
      x = "Duration (minutes, log10 scale)",
      y = "Number of Sessions"
    ) +
    theme_minimal()
```

\
Top 10 Charging Station Boxplot; Brauche ich vermutlich nicht.

```{r}
charging_session_raw <- charging_session_raw %>%
  mutate(
    StartDateTime = ymd_hms(paste(`Start Date`, `Start Time`)),
    EndDateTime = ymd_hms(paste(`End Date`, `End Time`)),
    duration_minutes = as.numeric(difftime(EndDateTime, StartDateTime, units = "mins"))
  ) %>%
  filter(duration_minutes > 0, duration_minutes <= 1440)

filtered_data <- charging_session_raw %>%
  filter(duration_minutes <= quantile(duration_minutes, 0.99, na.rm = TRUE))

ggplot(filtered_data, aes(x = as.factor(Id), y = duration_minutes)) +
  geom_boxplot(outlier.alpha = 0.25, fill = "lightgreen") +
  labs(
    title = "Session Duration by Charging Station",
    x = "Charging Station",
    y = "Duration (minutes)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Feature Engineering:

1.  Time based & Location features already in the dataset;
    1.  Avg power zum Dataset hinzufügen
2.  Mapping of shortest distance to the next station;
3.  Mapping of nearest Street classification (Bundesstraße, Landstraße...)
4.  mapping of nearest point of interest & the classification of it;
    1.  Supermarket; Highway station;

```{r}
charging_sessions_filtered <- charging_sessions_filtered %>%
  mutate(
    avg_power_kW   =  `Total kWh`  / duration_hours  
  )
```

```{r}
colnames(charging_sessions_filtered)
colnames(charging_points_raw)

```

Correct Joined ML Ready Table:\

```{r}
dir_out <- "../02_Processed_Data"
if (!dir.exists(dir_out)) dir.create(dir_out, recursive = TRUE)

# --- helper for datetime parsing
parse_dt <- function(date_chr, time_chr) {
  x <- str_squish(paste0(date_chr, " ", time_chr))
  parse_date_time(x, orders = c("Y-m-d H:M:S", "Y-m-d H:M"), tz = "UTC", exact = FALSE)
}

# --- 1) Filter sessions ---
charging_sessions_filtered <- charging_session_raw %>%
  mutate(
    StartDateTime = parse_dt(`Start Date`, `Start Time`),
    EndDateTime   = parse_dt(`End Date`,   `End Time`)
  ) %>%
  filter(!is.na(StartDateTime), !is.na(EndDateTime)) %>%
  mutate(
    duration_minutes = as.numeric(difftime(EndDateTime, StartDateTime, units = "mins")),
    duration_hours   = duration_minutes / 60
  ) %>%
  filter(
    duration_minutes > 0, duration_minutes <= 1440,
    `Total kWh` > 0, `Total kWh` <= 100
  ) %>%
  mutate(avg_power_kW = `Total kWh` / pmax(duration_hours, 1e-9))

write_csv(charging_sessions_filtered, file.path(dir_out, "charging_sessions_filtered.csv"))

# --- 2) Station geos (BNG -> WGS84 lon/lat) ---
crs_input <- 27700
cp_sf <- st_as_sf(charging_points_raw, coords = c("x","y"), crs = crs_input, remove = FALSE)
cp_ll <- st_transform(cp_sf, 4326)
coords <- st_coordinates(cp_ll)

charging_points_geo <- charging_points_raw %>%
  mutate(lon = coords[,1], lat = coords[,2])

# --- 3) Join sessions with station metadata ---
sessions_full <- charging_sessions_filtered %>%
  left_join(
    charging_points_geo %>%
      select(Id, CP_Name, CH_SPEED, CH_TYPE, CON_TYPE, CP_CHARGE, USAGE_,
             OUTPUT1_kW, OUTPUT2_kW, lon, lat),
    by = "Id"
  ) %>%
  drop_na()   # remove rows with NAs after join

write_csv(sessions_full, file.path(dir_out, "sessions_enriched.csv"))

# --- 4) Daily aggregates per station ---
station_day <- sessions_full %>%
  mutate(date = as_date(StartDateTime)) %>%
  group_by(Id, date) %>%
  summarise(
    sessions_per_day   = n(),
    energy_per_day_kWh = sum(`Total kWh`, na.rm = TRUE),
    avg_duration_min   = mean(duration_minutes, na.rm = TRUE),
    avg_power_kW_day   = mean(avg_power_kW, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    dow        = wday(date, label = TRUE, week_start = 1),
    is_weekend = dow %in% c("Sat","Sun"),
    month      = month(date, label = TRUE),
    year       = year(date),
    week       = isoweek(date)
  ) %>%
  arrange(Id, date) %>%
  group_by(Id) %>%
  ungroup() %>%
  left_join(
    charging_points_geo %>%
      select(Id, CH_SPEED, CH_TYPE, CON_TYPE, CP_CHARGE, USAGE_,
             OUTPUT1_kW, OUTPUT2_kW, lon, lat),
    by = "Id"
  ) %>%
  drop_na()   # drop rows with any NA

write_csv(station_day, file.path(dir_out, "station_day_enriched.csv"))

cat("✅ Done.\n",
    "sessions_filtered:", nrow(charging_sessions_filtered), "rows\n",
    "sessions_enriched:", nrow(sessions_full), "rows\n",
    "station_day:", nrow(station_day), "rows\n")
```

```{r}
station_day %>%
  group_by(date) %>%
  summarise(total_sessions = sum(sessions_per_day), .groups = "drop") %>%
  ggplot(aes(x = date, y = total_sessions)) +
  geom_line(color = "steelblue", linewidth = 1) +
  labs(
    title = "Number of Charging Sessions per Day",
    x = "Date",
    y = "Sessions (all stations)"
  ) +
  theme_minimal()
```

Adding shortest distance

```{r}

# ==== packages ====
library(dplyr)
library(sf)
library(osmdata)
library(dodgr)
library(geodist)

stations <- charging_points_geo %>%
  filter(!is.na(lon), !is.na(lat)) %>%
  distinct(Id, lon, lat)

stations_sf <- st_as_sf(stations, coords = c("lon", "lat"), crs = 4326)

bb_poly <- stations_sf %>% st_union() %>% st_transform(3857) %>% st_buffer(10000) %>% st_transform(4326)
bb <- st_bbox(bb_poly)
# get only streets where cars can drive through
hw_keep <- c(
  "motorway","motorway_link","trunk","trunk_link","primary","primary_link",
  "secondary","secondary_link","tertiary","tertiary_link",
  "unclassified","residential","living_street","service"
)
net <- opq(bbox = bb) %>% add_osm_feature("highway", hw_keep) %>% osmdata_sf()
roads <- net$osm_lines
stopifnot(!is.null(roads), nrow(roads) > 0)
bad <- c("construction","proposed","disused")
if ("highway" %in% names(roads)) roads <- roads[!(roads$highway %in% bad), ]

graph <- weight_streetnet(roads, wt_profile = "motorcar")


xy <- st_coordinates(stations_sf)        
dmat_m <- dodgr_dists(graph, from = xy, to = xy) # in meters

nearest_m <- apply(dmat_m, 1, function(v) {
  v <- as.numeric(v)
  vpos <- v[is.finite(v) & v > 0]
  if (length(vpos)) min(vpos) else NA_real_
})

nn_df <- tibble::tibble(
  Id = stations$Id,
  nearest_station_dist_km = nearest_m / 1000
)

if (anyNA(nn_df$nearest_station_dist_km)) {
  dist_geo <- st_distance(stations_sf, stations_sf)  # meters
  nearest_geo_m <- apply(dist_geo, 1, function(v) {
    v <- as.numeric(v)
    vpos <- v[is.finite(v) & v > 0]
    if (length(vpos)) min(vpos) else NA_real_
  })
  fill <- which(is.na(nn_df$nearest_station_dist_km))
  nn_df$nearest_station_dist_km[fill] <- nearest_geo_m[fill] / 1000
}

station_day <- station_day %>% left_join(nn_df, by = "Id")

# quick check
summary(station_day$nearest_station_dist_km)

```

Population Data ; Feature engineering:\

```{r}
library(terra)

stations_ll  <- st_as_sf(charging_points_geo, coords = c("lon","lat"), crs = 4326, remove = FALSE)
stations_bng <- st_transform(stations_ll, 27700)

buf_m  <- 10000
area_bng <- st_buffer(st_union(stations_bng), buf_m)
bb_ll   <- st_bbox(st_transform(area_bng, 4326))

pop_path <- "../01_Raw_Data/population_UK.tif"  # your file
pop_r_ll <- rast(pop_path)
pop_r_cr <- crop(pop_r_ll, ext(bb_ll))
pop_r_bng <- project(pop_r_cr, "EPSG:27700", method = "bilinear")


outer_list <- lapply(st_geometry(stations_bng), function(g) st_buffer(g, 50000))
inner_list <- lapply(st_geometry(stations_bng), function(g) st_buffer(g,  100))
ring_list  <- Map(st_difference, outer_list, inner_list)
rings_bng  <- st_sfc(ring_list, crs = 27700)                  # length == nrow(stations_bng)
rings_v    <- vect(rings_bng)

# 3) Extract mean pop per ring → one row per station
pop_df <- terra::extract(pop_r_bng, rings_v, fun = mean, na.rm = TRUE)
# pop_df has columns: ID, <raster_name>. Use the 2nd column:
pop_mean <- as.numeric(pop_df[[2]])

stopifnot(length(pop_mean) == nrow(stations_ll))  # safety check

# 4) Attach to stations, then to station_day
station_pop <- charging_points_geo %>%
  distinct(Id, lon, lat) %>%
  mutate(pop_density_mean_50km = pop_mean)

station_day <- station_day %>%
  left_join(station_pop, by = "Id")
```

```{r}
library(sf)
library(terra)
library(dplyr)

# --- 0) Stations (WGS84 + BNG) ---
stations_ll  <- st_as_sf(charging_points_geo, coords = c("lon","lat"), crs = 4326, remove = FALSE)
stations_bng <- st_transform(stations_ll, 27700)  # British National Grid (meters)

# --- 1) Prep population raster (crop to AOI, reproject to BNG) ---
buf_m  <- 10000  # 10 km pad around all stations for cropping
area_bng <- st_buffer(st_union(stations_bng), buf_m)
bb_ll   <- st_bbox(st_transform(area_bng, 4326))

pop_path <- "../01_Raw_Data/population_UK.tif"  # <-- your file
pop_r_ll <- rast(pop_path)
pop_r_cr <- crop(pop_r_ll, ext(bb_ll))
pop_r_bng <- project(pop_r_cr, "EPSG:27700", method = "bilinear")

# --- 2) Helper: mean population within a buffer radius (meters) ---
mean_pop_in_radius <- function(stations_bng, pop_r_bng, radius_m) {
  # build one polygon per station
  polys <- st_buffer(st_geometry(stations_bng), radius_m)
  v     <- vect(st_sfc(polys, crs = 27700))
  vals  <- terra::extract(pop_r_bng, v, fun = mean, na.rm = TRUE)
  as.numeric(vals[[2]])  # second column holds the raster values
}

# Compute both radii
pop_mean_1km  <- mean_pop_in_radius(stations_bng, pop_r_bng,  1000)
pop_mean_10km <- mean_pop_in_radius(stations_bng, pop_r_bng, 10000)

stopifnot(length(pop_mean_1km)  == nrow(stations_bng))
stopifnot(length(pop_mean_10km) == nrow(stations_bng))

# --- 3) Attach to stations, then join to station_day ---
station_pop <- charging_points_geo %>%
  distinct(Id, lon, lat) %>%
  mutate(
    pop_density_mean_1km  = pop_mean_1km,
    pop_density_mean_10km = pop_mean_10km
  )

station_day <- station_day %>%
  left_join(station_pop, by = "Id")
```

```{r}
        
summary(station_day$pop_density_mean_1km)
summary(station_day$pop_density_mean_10km)
summary(station_day$pop_density_mean_50km)

```

```{r}
library(osmdata)
library(sf)
library(units)

stations <- charging_points_geo %>%
  filter(!is.na(lon), !is.na(lat)) %>%
  distinct(Id, lon, lat)


crs_m <- 27700   

stations_sf <- st_as_sf(stations, coords = c("lon","lat"), crs = 4326)
stations_m  <- st_transform(stations_sf, crs_m)


bbox_large <- st_bbox(st_buffer(stations_sf, 0.2))  # ~0.2° pad

hw_keep <- c(
  "motorway","motorway_link","trunk","trunk_link","primary","primary_link",
  "secondary","secondary_link","tertiary","tertiary_link",
  "unclassified","residential","living_street","service"
)

roads_osm <- opq(bbox = bbox_large) %>%
  add_osm_feature(key = "highway", value = hw_keep) %>%
  osmdata_sf()

roads <- roads_osm$osm_lines
stopifnot(!is.null(roads), nrow(roads) > 0)

# Drop non-drivable stragglers and go to meters CRS
bad <- c("construction","proposed","disused")
if ("highway" %in% names(roads)) roads <- roads[!(roads$highway %in% bad), ]
roads_m <- st_transform(roads, crs_m)

# (1a) nearest road class per station
nearest_idx   <- st_nearest_feature(stations_m, roads_m)
nearest_class <- roads_m$highway[nearest_idx]

# (1b) road length by class within buffer per station
buf_rd_m   <- 500
buffers_sf <- st_buffer(stations_m, buf_rd_m) %>%
  mutate(station_id = stations$Id) %>%      # tag each buffer with station Id
  select(station_id)

# Intersect roads with each buffer -> each piece inherits station_id
ints <- st_intersection(roads_m %>% select(highway), buffers_sf)
if (nrow(ints) == 0) stop("No road segments intersect the station buffers. Increase buf_rd_m or check CRS.")

road_len_by_class <- ints %>%
  mutate(len_m = as.numeric(st_length(geometry))) %>%
  st_drop_geometry() %>%
  group_by(station_id, highway) %>%
  summarise(road_len_m = sum(len_m, na.rm = TRUE), .groups = "drop")

# Pivot wide + total density (m per km^2)
buf_area_km2 <- as.numeric(set_units(pi * (buf_rd_m^2), m^2) %>% set_units(km^2))
road_len_wide <- pivot_wider(
  road_len_by_class,
  id_cols    = station_id,
  names_from = highway,
  values_from = road_len_m,
  values_fill = 0
) %>%
  mutate(
    road_len_total_m       = rowSums(across(where(is.numeric))),
    road_density_m_per_km2 = road_len_total_m / buf_area_km2
  ) %>%
  rename(Id = station_id)

places <- opq(bbox = bbox_large) %>%
  add_osm_feature(key = "place", value = c("city","town")) %>%
  osmdata_sf()

cities_pts  <- places$osm_points
cities_poly <- places$osm_multipolygons
cities_list <- list()

if (!is.null(cities_pts)  && nrow(cities_pts)  > 0) cities_list[[length(cities_list)+1]] <- st_transform(cities_pts,  4326) %>% select(name, place, geometry)
if (!is.null(cities_poly) && nrow(cities_poly) > 0) {
  cent <- st_point_on_surface(st_transform(cities_poly, 4326))
  cities_list[[length(cities_list)+1]] <- cent %>% select(name, place, geometry)
}
stopifnot(length(cities_list) > 0)
cities_all <- do.call(rbind, cities_list)

dist_mat <- st_distance(stations_sf, cities_all)   # meters
nearest_city_km <- apply(dist_mat, 1, function(v) {
  v <- as.numeric(v)
  if (all(!is.finite(v))) NA_real_ else min(v, na.rm = TRUE) / 1000
})

stations_features <- stations %>%
  mutate(
    nearest_road_class = nearest_class,
    dist_to_city_km    = nearest_city_km
  ) %>%
  left_join(road_len_wide, by = "Id")

stopifnot(nrow(stations_features) == nrow(stations)) 
summary(stations_features$road_density_m_per_km2)


station_day <- station_day %>%
  left_join(stations_features, by = "Id")
```

```{r}
colnames(station_day)
write_csv(station_day, file.path(dir_out, "station_day_rdy.csv"))
```
